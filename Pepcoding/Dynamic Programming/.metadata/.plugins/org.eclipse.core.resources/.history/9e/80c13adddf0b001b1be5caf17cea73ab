import java.util.Arrays;
import java.util.LinkedList;
import java.util.Map;

public class _007_Print_MinCostPaths2 {

	private static class Node {
		int x;
		int y;
		String psf;

		public Node(int x, int y, String psf) {
			super();
			this.x = x;
			this.y = y;
			this.psf = psf;
		}

	}

	public static void main(String[] args) {

		int[][] arr = { { 0, 1, 4, 2, 8, 2 }, 
						{ 4, 3, 6, 5, 0, 4 }, 
						{ 1, 2, 4, 1, 4, 6 }, 
						{ 2, 0, 7, 3, 2, 2 },
						{ 3, 1, 5, 9, 2, 4 }, 
						{ 2, 7, 0, 8, 5, 1 } };
		
		Integer[][] dp = new Integer[arr.length][arr[0].length];

		int minPath = getMinPath(arr, 0, 0, dp);
		System.out.println(minPath);

		for (Integer[] d : dp) {
			System.out.println(Arrays.toString(d));
		}

		bfs(dp);

	}

	private static void bfs(Integer[][] dp) {

		LinkedList<Node> q = new LinkedList<Node>();
		q.add(new Node(0, 0, ""));
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			for(int i = 0; i < size; i++) {
				
				Node curr = q.poll();
				int x = curr.x;
				int y = curr.y;
				String psf = curr.psf;
				
				if(x == dp.length - 1 && y == dp[0].length - 1) {
					System.out.println(psf);
				}else if(x == dp.length - 1) {
					q.add(new Node(x, y + 1, psf + "H"));
				}else if(y == dp[0].length - 1) {
					q.add(new Node(x + 1, y, psf + "V"));
				}else {
					
					if(dp[x][y + 1] < dp[x + 1][y]) {
						q.add(new Node(x, y + 1, psf + "H"));
					}else if() {
						
					}else {
						
					}
					
				}
				
			}
		}
		
		
	}

	private static int getMinPath(int[][] arr, int i, int j, Integer[][] dp) {

		if (i >= arr.length || j >= arr[0].length) {
			return Integer.MAX_VALUE;
		}

		if (i == arr.length - 1 && j == arr[0].length - 1) {
			return dp[i][j] = arr[i][j];
		}

		if (dp[i][j] != null) {
			return dp[i][j];
		}

		return dp[i][j] = Math.min(getMinPath(arr, i + 1, j, dp), getMinPath(arr, i, j + 1, dp)) + arr[i][j];
	}
}
